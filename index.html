<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex Mastery Course</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #fafafa;
            color: #2d2d2d;
            min-height: 100vh;
            display: flex;
            transition: background 0.3s ease;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid #e0e0e0;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
            position: fixed;
            left: 0;
            top: 0;
            z-index: 100;
        }

        .sidebar.collapsed {
            transform: translateX(-280px);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f8f8;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: 600;
            color: #2d2d2d;
            margin-bottom: 8px;
        }

        .sidebar-subtitle {
            font-size: 12px;
            color: #999;
        }

        .module {
            margin-bottom: 4px;
        }

        .module-header {
            padding: 12px 20px;
            background: #fafafa;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background 0.2s;
            font-size: 13px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .module-header:hover {
            background: #f0f0f0;
        }

        .module-arrow {
            transition: transform 0.2s;
            font-size: 10px;
        }

        .module.expanded .module-arrow {
            transform: rotate(90deg);
        }

        .module-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .module.expanded .module-content {
            max-height: 500px;
        }

        .lesson {
            padding: 10px 20px 10px 32px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #4a4a4a;
        }

        .lesson:hover {
            background: #f5f5f5;
        }

        .lesson.active {
            background: #e8f5e9;
            color: #2e7d32;
            font-weight: 500;
        }

        .lesson.completed {
            color: #4caf50;
        }

        .lesson-status {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #e0e0e0;
            flex-shrink: 0;
        }

        .lesson.completed .lesson-status {
            background: #4caf50;
            border-color: #4caf50;
            position: relative;
        }

        .lesson.completed .lesson-status::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px;
        }

        .lesson.active .lesson-status {
            border-color: #2e7d32;
            border-width: 3px;
        }

        /* Toggle Button */
        .sidebar-toggle {
            position: fixed;
            left: 20px;
            top: 20px;
            z-index: 101;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #666;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .sidebar-toggle:hover {
            background: #f5f5f5;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .sidebar-toggle.sidebar-open {
            left: 300px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 280px;
            padding: 100px 60px 60px;
            max-width: 900px;
            transition: margin-left 0.3s ease;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .main-content.sidebar-collapsed {
            margin-left: 0;
            padding: 100px 40px 60px;
        }

        /* Progress Bar */
        .progress-section {
            margin-bottom: 40px;
            padding: 0 4px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .progress-text {
            font-size: 12px;
            color: #999;
            font-weight: 500;
        }

        .progress-bar {
            height: 4px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #66bb6a);
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        /* Lesson Content */
        .lesson-header {
            margin-bottom: 40px;
        }

        .lesson-title {
            font-size: 32px;
            font-weight: 600;
            color: #2d2d2d;
            margin-bottom: 16px;
            line-height: 1.2;
        }

        .lesson-description {
            font-size: 18px;
            color: #666;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .concept-box {
            background: #f0f7ff;
            border-left: 4px solid #2196f3;
            padding: 20px 24px;
            margin-bottom: 32px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .concept-title {
            font-size: 14px;
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .concept-content {
            font-size: 14px;
            color: #333;
            line-height: 1.6;
        }

        .concept-content code {
            background: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 13px;
            color: #d63384;
        }

        /* Input Section */
        .input-wrapper {
            position: relative;
            margin-bottom: 32px;
        }

        .regex-input {
            width: 100%;
            padding: 16px 20px;
            font-size: 20px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            color: #2d2d2d;
            transition: all 0.2s ease;
            letter-spacing: 0.5px;
        }

        .regex-input:focus {
            outline: none;
            border-color: #7c7c7c;
            box-shadow: 0 0 0 3px rgba(124, 124, 124, 0.1);
        }

        .regex-input.success {
            border-color: #4caf50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .regex-input.partial {
            border-color: #ff9800;
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.1);
        }

        .regex-input.error {
            border-color: #f44336;
        }

        .input-label {
            position: absolute;
            top: -10px;
            left: 16px;
            background: white;
            padding: 0 4px;
            font-size: 12px;
            color: #999;
        }

        /* Hint System */
        .hint-box {
            margin-top: 12px;
            padding: 12px 16px;
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            border-radius: 4px;
            font-size: 14px;
            color: #856404;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            display: none;
        }

        .hint-box.visible {
            opacity: 1;
            transform: translateY(0);
            display: block;
        }

        /* Test Cases */
        .test-section {
            margin-bottom: 40px;
        }

        .test-header {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .test-string {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            margin-bottom: 12px;
            background: white;
            border-radius: 8px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 14px;
            transition: all 0.2s ease;
            border: 1px solid #e0e0e0;
            position: relative;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .test-string.match-expected {
            border-left: 3px solid #4caf50;
        }

        .test-string.no-match-expected {
            border-left: 3px solid #999;
        }

        .test-string.correct {
            background: #f1f8e9;
        }

        .test-string.incorrect {
            background: #ffebee;
        }

        .test-string-text {
            flex: 1;
            color: #2d2d2d;
        }

        .test-string-status {
            margin-left: 16px;
            font-size: 18px;
            opacity: 0.3;
            transition: opacity 0.2s ease;
        }

        .test-string-status.active {
            opacity: 1;
        }

        .test-match-highlight {
            background: #ffeb3b;
            padding: 1px 2px;
            border-radius: 2px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 16px;
            margin-top: 32px;
            padding-top: 32px;
            border-top: 1px solid #e0e0e0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: #f5f5f5;
            transform: translateY(-1px);
        }

        .btn.primary {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .btn.primary:hover {
            background: #45a049;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .keyboard-hint {
            padding: 2px 6px;
            background: #f0f0f0;
            border-radius: 3px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 12px;
        }

        /* Success Message */
        .success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 200;
            padding: 20px;
        }

        .success-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .success-modal {
            background: white;
            padding: 40px 48px;
            border-radius: 16px;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            max-width: 400px;
            width: 100%;
            margin: 0 auto;
        }

        .success-overlay.show .success-modal {
            transform: scale(1);
        }

        .success-icon {
            font-size: 56px;
            color: #4caf50;
            margin-bottom: 20px;
            display: block;
        }

        .success-title {
            font-size: 28px;
            font-weight: 600;
            color: #2d2d2d;
            margin-bottom: 12px;
        }

        .success-subtitle {
            font-size: 16px;
            color: #666;
            margin-bottom: 32px;
            line-height: 1.4;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
            }
            
            .sidebar.collapsed {
                transform: translateX(-100%);
            }
            
            .main-content {
                margin-left: 0;
                padding: 100px 24px 60px;
            }
            
            .main-content.sidebar-collapsed {
                padding: 100px 20px 60px;
            }
            
            .sidebar-toggle.sidebar-open {
                left: 20px;
            }
            
            .lesson-title {
                font-size: 28px;
            }
            
            .lesson-description {
                font-size: 16px;
            }
            
            .controls {
                flex-direction: column;
                gap: 12px;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .main-content {
                padding: 100px 16px 60px;
            }
            
            .main-content.sidebar-collapsed {
                padding: 100px 16px 60px;
            }
            
            .concept-box {
                padding: 16px 20px;
                margin-left: -4px;
                margin-right: -4px;
            }
            
            .test-string {
                padding: 12px 16px;
                margin-left: -4px;
                margin-right: -4px;
            }
        }
        
        /* Safe area for devices with notches */
        @supports (padding: max(0px)) {
            .main-content {
                padding-left: max(60px, env(safe-area-inset-left) + 20px);
                padding-right: max(60px, env(safe-area-inset-right) + 20px);
            }
            
            .main-content.sidebar-collapsed {
                padding-left: max(40px, env(safe-area-inset-left) + 20px);
                padding-right: max(40px, env(safe-area-inset-right) + 20px);
            }
        }
    </style>
</head>
<body>
    <!-- Sidebar Navigation -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title">Regex Mastery</div>
            <div class="sidebar-subtitle">Complete Course • 50 Lessons</div>
        </div>
        <div id="courseIndex"></div>
    </div>

    <!-- Toggle Button -->
    <button class="sidebar-toggle sidebar-open" id="sidebarToggle">
        <span>☰</span>
        <span>Menu</span>
    </button>

    <!-- Main Content -->
    <div class="main-content" id="mainContent">
        <!-- Progress Section -->
        <div class="progress-section">
            <div class="progress-info">
                <span class="progress-text" id="progressText">Lesson 1 of 50</span>
                <span class="progress-text" id="progressPercent">0% Complete</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <!-- Lesson Content -->
        <div class="lesson-header">
            <h1 class="lesson-title" id="lessonTitle">Loading...</h1>
            <p class="lesson-description" id="lessonDescription">Loading...</p>
        </div>

        <!-- Concept Box -->
        <div class="concept-box" id="conceptBox">
            <div class="concept-title">Key Concept</div>
            <div class="concept-content" id="conceptContent">Loading...</div>
        </div>

        <!-- Input Section -->
        <div class="input-wrapper">
            <label class="input-label">Your Pattern</label>
            <input 
                type="text" 
                class="regex-input" 
                id="regexInput" 
                placeholder="Type your regex pattern..."
                autocomplete="off"
                spellcheck="false"
            />
            <div class="hint-box" id="hintBox"></div>
        </div>

        <!-- Test Cases -->
        <div class="test-section">
            <div class="test-header">Test Cases</div>
            <div id="testStrings"></div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="btn" id="prevBtn">
                <span>←</span>
                <span>Previous</span>
            </button>
            <button class="btn" id="hintBtn">
                <span class="keyboard-hint">Tab</span>
                <span>Get Hint</span>
            </button>
            <button class="btn" id="solutionBtn">
                <span>Show Solution</span>
            </button>
            <button class="btn primary" id="nextBtn">
                <span>Next Lesson</span>
                <span>→</span>
            </button>
        </div>
    </div>

    <!-- Success Overlay -->
    <div class="success-overlay" id="successOverlay">
        <div class="success-modal">
            <div class="success-icon">✓</div>
            <div class="success-title">Perfect!</div>
            <div class="success-subtitle">You've mastered this pattern</div>
            <button class="btn primary" id="continueBtn">Continue to Next Lesson</button>
        </div>
    </div>

    <script>
        // Course curriculum - organized by difficulty and concept
        const curriculum = [
            // Module 1: Basics
            {
                module: "Basics",
                lessons: [
                    {
                        title: "Literal Characters",
                        description: "Match exact characters in text",
                        concept: "The simplest regex patterns match literal characters exactly as they appear. For example, <code>cat</code> matches the exact sequence 'cat' in text.",
                        testStrings: [
                            { text: 'cat', shouldMatch: true },
                            { text: 'The cat sat', shouldMatch: true },
                            { text: 'category', shouldMatch: true },
                            { text: 'dog', shouldMatch: false },
                            { text: 'CAT', shouldMatch: false }
                        ],
                        solution: 'cat',
                        hints: [
                            'Simply type the exact characters you want to match',
                            'Remember: regex is case-sensitive by default',
                            'Solution: cat'
                        ]
                    },
                    {
                        title: "The Dot Wildcard",
                        description: "Use . to match any single character",
                        concept: "The dot <code>.</code> is a wildcard that matches any single character except line breaks. For example, <code>c.t</code> matches 'cat', 'cot', 'cut', etc.",
                        testStrings: [
                            { text: 'cat', shouldMatch: true },
                            { text: 'cot', shouldMatch: true },
                            { text: 'cut', shouldMatch: true },
                            { text: 'ct', shouldMatch: false },
                            { text: 'cart', shouldMatch: false }
                        ],
                        solution: 'c.t',
                        hints: [
                            'Use . to match any single character',
                            'Pattern: c_t where _ is any character',
                            'Solution: c.t'
                        ]
                    },
                    {
                        title: "Escaping Special Characters",
                        description: "Match literal dots and other special characters",
                        concept: "To match special regex characters literally (like . * + ? etc.), escape them with a backslash. <code>\\.</code> matches a literal dot.",
                        testStrings: [
                            { text: 'file.txt', shouldMatch: true },
                            { text: 'image.jpg', shouldMatch: true },
                            { text: 'doc.pdf', shouldMatch: true },
                            { text: 'file-txt', shouldMatch: false },
                            { text: 'filetxt', shouldMatch: false }
                        ],
                        solution: '\\.',
                        hints: [
                            'You need to match a literal dot',
                            'Escape special characters with backslash',
                            'Solution: \\.'
                        ]
                    }
                ]
            },
            // Module 2: Character Classes
            {
                module: "Character Classes",
                lessons: [
                    {
                        title: "Character Sets [abc]",
                        description: "Match any one character from a set",
                        concept: "Square brackets <code>[abc]</code> create a character set that matches any ONE of the enclosed characters. <code>[aeiou]</code> matches any vowel.",
                        testStrings: [
                            { text: 'cat', shouldMatch: true },
                            { text: 'bat', shouldMatch: true },
                            { text: 'rat', shouldMatch: true },
                            { text: 'mat', shouldMatch: false },
                            { text: 'sat', shouldMatch: false }
                        ],
                        solution: '[cbr]at',
                        hints: [
                            'Use square brackets to match one of several characters',
                            'Match words ending in "at" that start with c, b, or r',
                            'Solution: [cbr]at'
                        ]
                    },
                    {
                        title: "Character Ranges [a-z]",
                        description: "Match characters in a range",
                        concept: "Use a hyphen inside brackets to specify a range. <code>[a-z]</code> matches any lowercase letter, <code>[0-9]</code> matches any digit.",
                        testStrings: [
                            { text: 'a', shouldMatch: true },
                            { text: 'm', shouldMatch: true },
                            { text: 'z', shouldMatch: true },
                            { text: 'A', shouldMatch: false },
                            { text: '5', shouldMatch: false }
                        ],
                        solution: '[a-z]',
                        hints: [
                            'Use a hyphen to specify a range of characters',
                            'Match any lowercase letter',
                            'Solution: [a-z]'
                        ]
                    },
                    {
                        title: "Negated Sets [^abc]",
                        description: "Match any character NOT in the set",
                        concept: "A caret <code>^</code> at the start of a character set negates it. <code>[^0-9]</code> matches any non-digit character.",
                        testStrings: [
                            { text: 'a', shouldMatch: true },
                            { text: 'b', shouldMatch: true },
                            { text: '!', shouldMatch: true },
                            { text: '5', shouldMatch: false },
                            { text: '9', shouldMatch: false }
                        ],
                        solution: '[^0-9]',
                        hints: [
                            'Use ^ inside brackets to negate the set',
                            'Match anything that is NOT a digit',
                            'Solution: [^0-9]'
                        ]
                    },
                    {
                        title: "Digit Shorthand \\d",
                        description: "Use \\d to match any digit",
                        concept: "The <code>\\d</code> character class is shorthand for <code>[0-9]</code>. It matches any single digit.",
                        testStrings: [
                            { text: '0', shouldMatch: true },
                            { text: '5', shouldMatch: true },
                            { text: '9', shouldMatch: true },
                            { text: 'a', shouldMatch: false },
                            { text: '!', shouldMatch: false }
                        ],
                        solution: '\\d',
                        hints: [
                            'Use the digit character class',
                            'Shorthand for [0-9]',
                            'Solution: \\d'
                        ]
                    },
                    {
                        title: "Non-Digit \\D",
                        description: "Match any non-digit character",
                        concept: "The <code>\\D</code> character class is shorthand for <code>[^0-9]</code>. It matches any character that is NOT a digit.",
                        testStrings: [
                            { text: 'a', shouldMatch: true },
                            { text: 'Z', shouldMatch: true },
                            { text: '!', shouldMatch: true },
                            { text: '5', shouldMatch: false },
                            { text: '0', shouldMatch: false }
                        ],
                        solution: '\\D',
                        hints: [
                            'Use the non-digit character class',
                            'Opposite of \\d',
                            'Solution: \\D'
                        ]
                    },
                    {
                        title: "Word Characters \\w",
                        description: "Match letters, digits, and underscore",
                        concept: "The <code>\\w</code> character class matches word characters: <code>[A-Za-z0-9_]</code>. Useful for matching variable names.",
                        testStrings: [
                            { text: 'a', shouldMatch: true },
                            { text: '5', shouldMatch: true },
                            { text: '_', shouldMatch: true },
                            { text: '-', shouldMatch: false },
                            { text: '!', shouldMatch: false }
                        ],
                        solution: '\\w',
                        hints: [
                            'Use the word character class',
                            'Matches letters, digits, and underscore',
                            'Solution: \\w'
                        ]
                    },
                    {
                        title: "Whitespace \\s",
                        description: "Match spaces, tabs, and newlines",
                        concept: "The <code>\\s</code> character class matches any whitespace character including spaces, tabs, and line breaks.",
                        testStrings: [
                            { text: ' ', shouldMatch: true },
                            { text: '\t', shouldMatch: true },
                            { text: '\n', shouldMatch: true },
                            { text: 'a', shouldMatch: false },
                            { text: '5', shouldMatch: false }
                        ],
                        solution: '\\s',
                        hints: [
                            'Use the whitespace character class',
                            'Matches spaces, tabs, newlines',
                            'Solution: \\s'
                        ]
                    }
                ]
            },
            // Module 3: Anchors & Boundaries
            {
                module: "Anchors & Boundaries",
                lessons: [
                    {
                        title: "Start Anchor ^",
                        description: "Match patterns at the beginning of text",
                        concept: "The caret <code>^</code> anchor matches the start of a string. <code>^Hello</code> only matches 'Hello' at the beginning.",
                        testStrings: [
                            { text: 'Hello world', shouldMatch: true },
                            { text: 'Hello there', shouldMatch: true },
                            { text: 'Say Hello', shouldMatch: false },
                            { text: 'hello world', shouldMatch: false }
                        ],
                        solution: '^Hello',
                        hints: [
                            'Use ^ to match the start of the string',
                            'Must match "Hello" at the beginning',
                            'Solution: ^Hello'
                        ]
                    },
                    {
                        title: "End Anchor $",
                        description: "Match patterns at the end of text",
                        concept: "The dollar sign <code>$</code> anchor matches the end of a string. <code>world$</code> only matches 'world' at the end.",
                        testStrings: [
                            { text: 'Hello world', shouldMatch: true },
                            { text: 'world', shouldMatch: true },
                            { text: 'world peace', shouldMatch: false },
                            { text: 'worldwide', shouldMatch: false }
                        ],
                        solution: 'world$',
                        hints: [
                            'Use $ to match the end of the string',
                            'Must match "world" at the end',
                            'Solution: world$'
                        ]
                    },
                    {
                        title: "Word Boundary \\b",
                        description: "Match whole words only",
                        concept: "The <code>\\b</code> assertion matches a word boundary - the position between a word character and a non-word character.",
                        testStrings: [
                            { text: 'cat', shouldMatch: true },
                            { text: 'the cat sat', shouldMatch: true },
                            { text: 'category', shouldMatch: false },
                            { text: 'scatter', shouldMatch: false }
                        ],
                        solution: '\\bcat\\b',
                        hints: [
                            'Use \\b for word boundaries',
                            'Match "cat" as a whole word only',
                            'Solution: \\bcat\\b'
                        ]
                    },
                    {
                        title: "Non-Word Boundary \\B",
                        description: "Match within words, not at boundaries",
                        concept: "The <code>\\B</code> assertion matches a non-word boundary - positions where both sides are word characters or both are non-word characters.",
                        testStrings: [
                            { text: 'category', shouldMatch: true },
                            { text: 'scatter', shouldMatch: true },
                            { text: 'cat', shouldMatch: false },
                            { text: 'the cat', shouldMatch: false }
                        ],
                        solution: '\\Bcat',
                        hints: [
                            'Use \\B for non-word boundaries',
                            'Match "cat" within a word, not at the start',
                            'Solution: \\Bcat'
                        ]
                    }
                ]
            },
            // Module 4: Quantifiers
            {
                module: "Quantifiers",
                lessons: [
                    {
                        title: "Zero or More *",
                        description: "Match 0 or more occurrences",
                        concept: "The asterisk <code>*</code> quantifier matches zero or more of the preceding element. <code>ab*</code> matches 'a', 'ab', 'abb', etc.",
                        testStrings: [
                            { text: 'a', shouldMatch: true },
                            { text: 'ab', shouldMatch: true },
                            { text: 'abbb', shouldMatch: true },
                            { text: 'b', shouldMatch: false },
                            { text: 'ba', shouldMatch: false }
                        ],
                        solution: 'ab*',
                        hints: [
                            'Use * to match zero or more',
                            'Match "a" followed by zero or more "b"s',
                            'Solution: ab*'
                        ]
                    },
                    {
                        title: "One or More +",
                        description: "Match 1 or more occurrences",
                        concept: "The plus <code>+</code> quantifier matches one or more of the preceding element. <code>ab+</code> requires at least one 'b'.",
                        testStrings: [
                            { text: 'ab', shouldMatch: true },
                            { text: 'abbb', shouldMatch: true },
                            { text: 'a', shouldMatch: false },
                            { text: 'b', shouldMatch: false },
                            { text: 'ba', shouldMatch: false }
                        ],
                        solution: 'ab+',
                        hints: [
                            'Use + to match one or more',
                            'Match "a" followed by one or more "b"s',
                            'Solution: ab+'
                        ]
                    },
                    {
                        title: "Optional ?",
                        description: "Match 0 or 1 occurrence",
                        concept: "The question mark <code>?</code> makes the preceding element optional (0 or 1 occurrence). <code>colou?r</code> matches both 'color' and 'colour'.",
                        testStrings: [
                            { text: 'color', shouldMatch: true },
                            { text: 'colour', shouldMatch: true },
                            { text: 'colouur', shouldMatch: false },
                            { text: 'colr', shouldMatch: false }
                        ],
                        solution: 'colou?r',
                        hints: [
                            'Use ? to make something optional',
                            'Match both "color" and "colour"',
                            'Solution: colou?r'
                        ]
                    },
                    {
                        title: "Exact Count {n}",
                        description: "Match exactly n occurrences",
                        concept: "Curly braces <code>{n}</code> specify an exact count. <code>\\d{4}</code> matches exactly 4 digits.",
                        testStrings: [
                            { text: '1234', shouldMatch: true },
                            { text: '5678', shouldMatch: true },
                            { text: '123', shouldMatch: false },
                            { text: '12345', shouldMatch: false },
                            { text: 'abcd', shouldMatch: false }
                        ],
                        solution: '\\d{4}',
                        hints: [
                            'Use {n} to match exactly n times',
                            'Match exactly 4 digits',
                            'Solution: \\d{4}'
                        ]
                    },
                    {
                        title: "Range {n,m}",
                        description: "Match between n and m occurrences",
                        concept: "Use <code>{n,m}</code> to match between n and m occurrences. <code>\\d{2,4}</code> matches 2, 3, or 4 digits.",
                        testStrings: [
                            { text: '12', shouldMatch: true },
                            { text: '123', shouldMatch: true },
                            { text: '1234', shouldMatch: true },
                            { text: '1', shouldMatch: false },
                            { text: '12345', shouldMatch: false }
                        ],
                        solution: '^\\d{2,4}$',
                        hints: [
                            'Use {n,m} to match a range of occurrences',
                            'Match 2 to 4 digits (use anchors for exact match)',
                            'Solution: ^\\d{2,4}$'
                        ]
                    },
                    {
                        title: "Lazy Quantifiers",
                        description: "Match as few as possible with ?",
                        concept: "Adding <code>?</code> after a quantifier makes it lazy (non-greedy). <code>.*?</code> matches as few characters as possible.",
                        testStrings: [
                            { text: '<div>content</div>', shouldMatch: true },
                            { text: '<span>text</span>', shouldMatch: true },
                            { text: 'no tags here', shouldMatch: false }
                        ],
                        solution: '<.*?>',
                        hints: [
                            'Use ? after a quantifier to make it lazy',
                            'Match HTML tags without their content',
                            'Solution: <.*?>'
                        ]
                    }
                ]
            },
            // Module 5: Groups & Capturing
            {
                module: "Groups & Capturing",
                lessons: [
                    {
                        title: "Basic Groups ()",
                        description: "Group patterns together",
                        concept: "Parentheses <code>()</code> group patterns together. Groups can be quantified as a unit: <code>(ab)+</code> matches 'ab', 'abab', etc.",
                        testStrings: [
                            { text: 'ab', shouldMatch: true },
                            { text: 'abab', shouldMatch: true },
                            { text: 'ababab', shouldMatch: true },
                            { text: 'a', shouldMatch: false },
                            { text: 'abb', shouldMatch: false }
                        ],
                        solution: '(ab)+',
                        hints: [
                            'Use parentheses to group patterns',
                            'Match one or more occurrences of "ab"',
                            'Solution: (ab)+'
                        ]
                    },
                    {
                        title: "Alternation |",
                        description: "Match one pattern OR another",
                        concept: "The pipe <code>|</code> creates alternation (OR logic). <code>cat|dog</code> matches either 'cat' or 'dog'.",
                        testStrings: [
                            { text: 'cat', shouldMatch: true },
                            { text: 'dog', shouldMatch: true },
                            { text: 'bird', shouldMatch: false },
                            { text: 'catdog', shouldMatch: false }
                        ],
                        solution: '^(cat|dog)$',
                        hints: [
                            'Use | for alternation (OR)',
                            'Match exactly "cat" or "dog"',
                            'Solution: ^(cat|dog)$'
                        ]
                    },
                    {
                        title: "Non-Capturing Groups (?:)",
                        description: "Group without capturing",
                        concept: "Non-capturing groups <code>(?:)</code> group patterns without creating a capture. Useful for performance and when you don't need the matched text.",
                        testStrings: [
                            { text: 'http://example.com', shouldMatch: true },
                            { text: 'https://example.com', shouldMatch: true },
                            { text: 'ftp://example.com', shouldMatch: false }
                        ],
                        solution: '^(?:https?://).*',
                        hints: [
                            'Use (?:) for non-capturing groups',
                            'Match URLs starting with http:// or https://',
                            'Solution: ^(?:https?://).*'
                        ]
                    },
                    {
                        title: "Named Groups (?<name>)",
                        description: "Create named capture groups",
                        concept: "Named groups <code>(?&lt;name&gt;)</code> create captures with names instead of numbers. Useful for extracting specific parts.",
                        testStrings: [
                            { text: '2024-12-25', shouldMatch: true },
                            { text: '1999-01-01', shouldMatch: true },
                            { text: '24-12-25', shouldMatch: false },
                            { text: 'not-a-date', shouldMatch: false }
                        ],
                        solution: '(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})',
                        hints: [
                            'Use (?<name>) to create named groups',
                            'Match dates in YYYY-MM-DD format',
                            'Solution: (?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})'
                        ]
                    },
                    {
                        title: "Backreferences \\1",
                        description: "Reference captured groups",
                        concept: "Backreferences <code>\\1</code>, <code>\\2</code>, etc. match the same text as a previous capture group. Useful for finding duplicates.",
                        testStrings: [
                            { text: 'the the', shouldMatch: true },
                            { text: 'is is', shouldMatch: true },
                            { text: 'the cat', shouldMatch: false },
                            { text: 'that this', shouldMatch: false }
                        ],
                        solution: '\\b(\\w+)\\s+\\1\\b',
                        hints: [
                            'Use \\1 to reference the first capture group',
                            'Match repeated words',
                            'Solution: \\b(\\w+)\\s+\\1\\b'
                        ]
                    }
                ]
            },
            // Module 6: Lookarounds
            {
                module: "Lookarounds",
                lessons: [
                    {
                        title: "Positive Lookahead (?=)",
                        description: "Match only if followed by pattern",
                        concept: "Positive lookahead <code>(?=pattern)</code> matches a position followed by the pattern, without including it in the match.",
                        testStrings: [
                            { text: 'test@', shouldMatch: true },
                            { text: 'hello@', shouldMatch: true },
                            { text: 'test!', shouldMatch: false },
                            { text: 'hello', shouldMatch: false }
                        ],
                        solution: '\\w+(?=@)',
                        hints: [
                            'Use (?=) for positive lookahead',
                            'Match words followed by @',
                            'Solution: \\w+(?=@)'
                        ]
                    },
                    {
                        title: "Negative Lookahead (?!)",
                        description: "Match only if NOT followed by pattern",
                        concept: "Negative lookahead <code>(?!pattern)</code> matches a position NOT followed by the pattern.",
                        testStrings: [
                            { text: 'file.txt', shouldMatch: false },
                            { text: 'file.jpg', shouldMatch: true },
                            { text: 'document.pdf', shouldMatch: true },
                            { text: 'script.txt', shouldMatch: false }
                        ],
                        solution: '\\w+\\.(?!txt)',
                        hints: [
                            'Use (?!) for negative lookahead',
                            'Match filenames NOT ending with .txt',
                            'Solution: \\w+\\.(?!txt)'
                        ]
                    },
                    {
                        title: "Positive Lookbehind (?<=)",
                        description: "Match only if preceded by pattern",
                        concept: "Positive lookbehind <code>(?&lt;=pattern)</code> matches a position preceded by the pattern.",
                        testStrings: [
                            { text: '$100', shouldMatch: true },
                            { text: '$50', shouldMatch: true },
                            { text: '€100', shouldMatch: false },
                            { text: '100', shouldMatch: false }
                        ],
                        solution: '(?<=\\$)\\d+',
                        hints: [
                            'Use (?<=) for positive lookbehind',
                            'Match numbers preceded by $',
                            'Solution: (?<=\\$)\\d+'
                        ]
                    },
                    {
                        title: "Negative Lookbehind (?<!)",
                        description: "Match only if NOT preceded by pattern",
                        concept: "Negative lookbehind <code>(?&lt;!pattern)</code> matches a position NOT preceded by the pattern.",
                        testStrings: [
                            { text: 'cat', shouldMatch: true },
                            { text: ' cat', shouldMatch: true },
                            { text: '-cat', shouldMatch: false },
                            { text: '_cat', shouldMatch: false }
                        ],
                        solution: '(?<![_-])cat',
                        hints: [
                            'Use (?<!) for negative lookbehind',
                            'Match "cat" not preceded by _ or -',
                            'Solution: (?<![_-])cat'
                        ]
                    }
                ]
            },
            // Module 7: Real-World Patterns
            {
                module: "Real-World Patterns",
                lessons: [
                    {
                        title: "Email Validation",
                        description: "Match valid email addresses",
                        concept: "Email validation requires matching username, @ symbol, domain, and TLD. A robust pattern handles special characters and multiple subdomains.",
                        testStrings: [
                            { text: 'user@example.com', shouldMatch: true },
                            { text: 'test.user+tag@domain.co.uk', shouldMatch: true },
                            { text: 'admin_123@company-name.org', shouldMatch: true },
                            { text: '@invalid.com', shouldMatch: false },
                            { text: 'user@', shouldMatch: false },
                            { text: 'user@domain', shouldMatch: false }
                        ],
                        solution: '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$',
                        hints: [
                            'Username: letters, numbers, _.+-',
                            'Domain: letters, numbers, hyphens',
                            'Must have @ and at least one dot',
                            'Solution: ^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'
                        ]
                    },
                    {
                        title: "Phone Numbers",
                        description: "Match US phone number formats",
                        concept: "Phone numbers can appear in various formats. A flexible pattern should handle common variations.",
                        testStrings: [
                            { text: '123-456-7890', shouldMatch: true },
                            { text: '(123) 456-7890', shouldMatch: true },
                            { text: '123.456.7890', shouldMatch: true },
                            { text: '123456789', shouldMatch: false },
                            { text: '12-345-6789', shouldMatch: false }
                        ],
                        solution: '^(\\(\\d{3}\\)|\\d{3})[-.\\s]?\\d{3}[-.\\s]?\\d{4}$',
                        hints: [
                            'Handle optional parentheses for area code',
                            'Allow various separators: -, ., or space',
                            'Pattern: 3 digits, separator, 3 digits, separator, 4 digits',
                            'Solution: ^(\\(\\d{3}\\)|\\d{3})[-.\\s]?\\d{3}[-.\\s]?\\d{4}$'
                        ]
                    },
                    {
                        title: "URLs",
                        description: "Match web URLs",
                        concept: "URL matching should handle protocols, domains, paths, and query strings.",
                        testStrings: [
                            { text: 'http://example.com', shouldMatch: true },
                            { text: 'https://www.google.com/search', shouldMatch: true },
                            { text: 'https://github.com/user/repo', shouldMatch: true },
                            { text: 'ftp://files.com', shouldMatch: false },
                            { text: 'not-a-url', shouldMatch: false }
                        ],
                        solution: '^https?://[\\w.-]+\\.[a-z]{2,}(/.*)?$',
                        hints: [
                            'Start with http:// or https://',
                            'Domain with at least one dot',
                            'Optional path after domain',
                            'Solution: ^https?://[\\w.-]+\\.[a-z]{2,}(/.*)?$'
                        ]
                    },
                    {
                        title: "IP Addresses",
                        description: "Match IPv4 addresses",
                        concept: "IPv4 addresses consist of four numbers (0-255) separated by dots.",
                        testStrings: [
                            { text: '192.168.1.1', shouldMatch: true },
                            { text: '10.0.0.0', shouldMatch: true },
                            { text: '255.255.255.255', shouldMatch: true },
                            { text: '256.1.1.1', shouldMatch: false },
                            { text: '192.168.1', shouldMatch: false }
                        ],
                        solution: '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$',
                        hints: [
                            'Each octet: 0-255',
                            'Four octets separated by dots',
                            'Handle: 0-9, 10-99, 100-199, 200-249, 250-255',
                            'Complex but accurate pattern needed'
                        ]
                    },
                    {
                        title: "Credit Card Numbers",
                        description: "Match credit card formats",
                        concept: "Credit cards typically have 13-19 digits, often displayed in groups of 4.",
                        testStrings: [
                            { text: '4111111111111111', shouldMatch: true },
                            { text: '4111-1111-1111-1111', shouldMatch: true },
                            { text: '4111 1111 1111 1111', shouldMatch: true },
                            { text: '411111111111111', shouldMatch: false },
                            { text: '4111-1111-1111', shouldMatch: false }
                        ],
                        solution: '^\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}$',
                        hints: [
                            'Four groups of 4 digits',
                            'Optional spaces or hyphens between groups',
                            'Total of 16 digits',
                            'Solution: ^\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}$'
                        ]
                    },
                    {
                        title: "Hex Color Codes",
                        description: "Match hexadecimal color codes",
                        concept: "Hex colors start with # and have either 3 or 6 hexadecimal characters.",
                        testStrings: [
                            { text: '#FF5733', shouldMatch: true },
                            { text: '#fff', shouldMatch: true },
                            { text: '#000000', shouldMatch: true },
                            { text: 'FF5733', shouldMatch: false },
                            { text: '#GGGGGG', shouldMatch: false },
                            { text: '#12345', shouldMatch: false }
                        ],
                        solution: '^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$',
                        hints: [
                            'Start with #',
                            'Either 3 or 6 hex characters',
                            'Hex: 0-9, A-F (case insensitive)',
                            'Solution: ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$'
                        ]
                    },
                    {
                        title: "Dates (ISO Format)",
                        description: "Match dates in YYYY-MM-DD format",
                        concept: "ISO date format with basic validation for month (01-12) and day (01-31) ranges.",
                        testStrings: [
                            { text: '2024-12-25', shouldMatch: true },
                            { text: '1999-01-01', shouldMatch: true },
                            { text: '2024-06-15', shouldMatch: true },
                            { text: '2024-13-01', shouldMatch: false },
                            { text: '24-12-25', shouldMatch: false },
                            { text: '2024/12/25', shouldMatch: false }
                        ],
                        solution: '^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$',
                        hints: [
                            'Year: 4 digits',
                            'Month: 01-12',
                            'Day: 01-31',
                            'Solution: ^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$'
                        ]
                    },
                    {
                        title: "Time (24-hour)",
                        description: "Match time in HH:MM format",
                        concept: "24-hour time format with hours (00-23) and minutes (00-59).",
                        testStrings: [
                            { text: '00:00', shouldMatch: true },
                            { text: '23:59', shouldMatch: true },
                            { text: '12:30', shouldMatch: true },
                            { text: '24:00', shouldMatch: false },
                            { text: '12:60', shouldMatch: false },
                            { text: '1:30', shouldMatch: false }
                        ],
                        solution: '^([01][0-9]|2[0-3]):[0-5][0-9]$',
                        hints: [
                            'Hours: 00-23',
                            'Minutes: 00-59',
                            'Both must be 2 digits',
                            'Solution: ^([01][0-9]|2[0-3]):[0-5][0-9]$'
                        ]
                    },
                    {
                        title: "Passwords",
                        description: "Strong password with requirements",
                        concept: "Password must contain at least one uppercase, one lowercase, one digit, and be 8+ characters.",
                        testStrings: [
                            { text: 'Pass123!', shouldMatch: true },
                            { text: 'SecureP@ss9', shouldMatch: true },
                            { text: 'MyPassw0rd', shouldMatch: true },
                            { text: 'password', shouldMatch: false },
                            { text: 'PASSWORD123', shouldMatch: false },
                            { text: 'Pass!', shouldMatch: false }
                        ],
                        solution: '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$',
                        hints: [
                            'Use positive lookaheads for requirements',
                            '(?=.*[a-z]) ensures lowercase',
                            '(?=.*[A-Z]) ensures uppercase',
                            '(?=.*\\d) ensures digit',
                            'Solution: ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$'
                        ]
                    },
                    {
                        title: "HTML Tags",
                        description: "Match HTML opening and closing tags",
                        concept: "Match paired HTML tags using backreferences to ensure opening and closing tags match.",
                        testStrings: [
                            { text: '<div>content</div>', shouldMatch: true },
                            { text: '<span>text</span>', shouldMatch: true },
                            { text: '<h1>Title</h1>', shouldMatch: true },
                            { text: '<div>content</span>', shouldMatch: false },
                            { text: '<div>content', shouldMatch: false }
                        ],
                        solution: '<([a-z]+)>.*?</\\1>',
                        hints: [
                            'Capture the tag name',
                            'Use lazy quantifier for content',
                            'Backreference to match closing tag',
                            'Solution: <([a-z]+)>.*?</\\1>'
                        ]
                    }
                ]
            }
        ];

        // State management
        let currentModuleIndex = 0;
        let currentLessonIndex = 0;
        let currentHintIndex = 0;
        let completedLessons = new Set();

        // DOM elements
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const mainContent = document.getElementById('mainContent');
        const courseIndex = document.getElementById('courseIndex');
        const regexInput = document.getElementById('regexInput');
        const hintBox = document.getElementById('hintBox');
        const testStrings = document.getElementById('testStrings');
        const lessonTitle = document.getElementById('lessonTitle');
        const lessonDescription = document.getElementById('lessonDescription');
        const conceptContent = document.getElementById('conceptContent');
        const progressText = document.getElementById('progressText');
        const progressPercent = document.getElementById('progressPercent');
        const progressFill = document.getElementById('progressFill');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const hintBtn = document.getElementById('hintBtn');
        const solutionBtn = document.getElementById('solutionBtn');
        const successOverlay = document.getElementById('successOverlay');
        const continueBtn = document.getElementById('continueBtn');

        // Build course index
        function buildCourseIndex() {
            courseIndex.innerHTML = '';
            let lessonNumber = 1;

            curriculum.forEach((module, moduleIdx) => {
                const moduleDiv = document.createElement('div');
                moduleDiv.className = 'module';
                if (moduleIdx === 0) moduleDiv.classList.add('expanded');

                const moduleHeader = document.createElement('div');
                moduleHeader.className = 'module-header';
                moduleHeader.innerHTML = `
                    <span>${module.module}</span>
                    <span class="module-arrow">▶</span>
                `;
                moduleHeader.onclick = () => toggleModule(moduleIdx);

                const moduleContent = document.createElement('div');
                moduleContent.className = 'module-content';

                module.lessons.forEach((lesson, lessonIdx) => {
                    const lessonDiv = document.createElement('div');
                    lessonDiv.className = 'lesson';
                    lessonDiv.dataset.module = moduleIdx;
                    lessonDiv.dataset.lesson = lessonIdx;
                    
                    const lessonKey = `${moduleIdx}-${lessonIdx}`;
                    if (completedLessons.has(lessonKey)) {
                        lessonDiv.classList.add('completed');
                    }
                    if (moduleIdx === currentModuleIndex && lessonIdx === currentLessonIndex) {
                        lessonDiv.classList.add('active');
                    }

                    lessonDiv.innerHTML = `
                        <span class="lesson-status"></span>
                        <span>${lessonNumber}. ${lesson.title}</span>
                    `;
                    lessonDiv.onclick = () => goToLesson(moduleIdx, lessonIdx);

                    moduleContent.appendChild(lessonDiv);
                    lessonNumber++;
                });

                moduleDiv.appendChild(moduleHeader);
                moduleDiv.appendChild(moduleContent);
                courseIndex.appendChild(moduleDiv);
            });
        }

        function toggleModule(moduleIdx) {
            const modules = document.querySelectorAll('.module');
            modules[moduleIdx].classList.toggle('expanded');
        }

        function goToLesson(moduleIdx, lessonIdx) {
            currentModuleIndex = moduleIdx;
            currentLessonIndex = lessonIdx;
            loadLesson();
        }

        function loadLesson() {
            const lesson = curriculum[currentModuleIndex].lessons[currentLessonIndex];
            
            // Update UI
            lessonTitle.textContent = lesson.title;
            lessonDescription.textContent = lesson.description;
            conceptContent.innerHTML = lesson.concept;
            
            // Reset state
            regexInput.value = '';
            regexInput.classList.remove('success', 'error', 'partial');
            currentHintIndex = 0;
            hintBox.classList.remove('visible');
            
            // Update progress
            updateProgress();
            
            // Render test strings
            renderTestStrings(lesson.testStrings);
            
            // Update navigation
            updateNavigation();
            
            // Update sidebar
            updateSidebarActiveLesson();
            
            // Focus input
            regexInput.focus();
        }

        function renderTestStrings(strings) {
            testStrings.innerHTML = '';
            strings.forEach(testString => {
                const div = document.createElement('div');
                div.className = `test-string ${testString.shouldMatch ? 'match-expected' : 'no-match-expected'}`;
                div.innerHTML = `
                    <span class="test-string-text">${escapeHtml(testString.text)}</span>
                    <span class="test-string-status">${testString.shouldMatch ? '✓' : '✗'}</span>
                `;
                testStrings.appendChild(div);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function validateRegex() {
            const pattern = regexInput.value;
            const lesson = curriculum[currentModuleIndex].lessons[currentLessonIndex];
            
            if (!pattern) {
                resetTestStrings();
                return;
            }

            let regex;
            try {
                regex = new RegExp(pattern);
            } catch (e) {
                regexInput.classList.add('error');
                regexInput.classList.remove('success', 'partial');
                resetTestStrings();
                return;
            }

            regexInput.classList.remove('error');
            
            let correctCount = 0;
            const testStringElements = testStrings.querySelectorAll('.test-string');
            
            lesson.testStrings.forEach((testString, index) => {
                const element = testStringElements[index];
                const statusElement = element.querySelector('.test-string-status');
                const matches = regex.test(testString.text);
                
                if (matches === testString.shouldMatch) {
                    element.classList.add('correct');
                    element.classList.remove('incorrect');
                    statusElement.classList.add('active');
                    correctCount++;
                } else {
                    element.classList.remove('correct');
                    element.classList.add('incorrect');
                    statusElement.classList.remove('active');
                }
            });

            const totalCount = lesson.testStrings.length;
            if (correctCount === totalCount && pattern) {
                regexInput.classList.add('success');
                regexInput.classList.remove('partial');
                markLessonComplete();
                showSuccess();
            } else if (correctCount > 0) {
                regexInput.classList.add('partial');
                regexInput.classList.remove('success');
            } else {
                regexInput.classList.remove('success', 'partial');
            }
        }

        function resetTestStrings() {
            const testStringElements = testStrings.querySelectorAll('.test-string');
            testStringElements.forEach(element => {
                element.classList.remove('correct', 'incorrect');
                element.querySelector('.test-string-status').classList.remove('active');
            });
        }

        function showHint() {
            const lesson = curriculum[currentModuleIndex].lessons[currentLessonIndex];
            if (currentHintIndex < lesson.hints.length) {
                hintBox.textContent = lesson.hints[currentHintIndex];
                hintBox.classList.add('visible');
                currentHintIndex++;
            }
        }

        function showSolution() {
            const lesson = curriculum[currentModuleIndex].lessons[currentLessonIndex];
            regexInput.value = lesson.solution;
            validateRegex();
        }

        function showSuccess() {
            successOverlay.classList.add('show');
        }

        function hideSuccess() {
            successOverlay.classList.remove('show');
        }

        function markLessonComplete() {
            const lessonKey = `${currentModuleIndex}-${currentLessonIndex}`;
            completedLessons.add(lessonKey);
            localStorage.setItem('completedLessons', JSON.stringify([...completedLessons]));
            updateSidebarActiveLesson();
            updateProgress();
        }

        function updateSidebarActiveLesson() {
            document.querySelectorAll('.lesson').forEach(lesson => {
                lesson.classList.remove('active');
                const moduleIdx = parseInt(lesson.dataset.module);
                const lessonIdx = parseInt(lesson.dataset.lesson);
                const lessonKey = `${moduleIdx}-${lessonIdx}`;
                
                if (completedLessons.has(lessonKey)) {
                    lesson.classList.add('completed');
                }
                
                if (moduleIdx === currentModuleIndex && lessonIdx === currentLessonIndex) {
                    lesson.classList.add('active');
                }
            });
        }

        function updateProgress() {
            const totalLessons = curriculum.reduce((sum, module) => sum + module.lessons.length, 0);
            const currentLessonNumber = curriculum.slice(0, currentModuleIndex).reduce((sum, module) => sum + module.lessons.length, 0) + currentLessonIndex + 1;
            const completedCount = completedLessons.size;
            const percentage = Math.round((completedCount / totalLessons) * 100);
            
            progressText.textContent = `Lesson ${currentLessonNumber} of ${totalLessons}`;
            progressPercent.textContent = `${percentage}% Complete`;
            progressFill.style.width = `${percentage}%`;
        }

        function updateNavigation() {
            // Previous button
            if (currentModuleIndex === 0 && currentLessonIndex === 0) {
                prevBtn.disabled = true;
            } else {
                prevBtn.disabled = false;
            }
            
            // Next button
            const isLastLesson = currentModuleIndex === curriculum.length - 1 && 
                                currentLessonIndex === curriculum[currentModuleIndex].lessons.length - 1;
            if (isLastLesson) {
                nextBtn.textContent = 'Complete Course';
            } else {
                nextBtn.innerHTML = '<span>Next Lesson</span><span>→</span>';
            }
        }

        function nextLesson() {
            const currentModule = curriculum[currentModuleIndex];
            
            if (currentLessonIndex < currentModule.lessons.length - 1) {
                currentLessonIndex++;
            } else if (currentModuleIndex < curriculum.length - 1) {
                currentModuleIndex++;
                currentLessonIndex = 0;
            } else {
                // Course complete
                alert('Congratulations! You\'ve completed the Regex Mastery course!');
                return;
            }
            
            loadLesson();
        }

        function previousLesson() {
            if (currentLessonIndex > 0) {
                currentLessonIndex--;
            } else if (currentModuleIndex > 0) {
                currentModuleIndex--;
                currentLessonIndex = curriculum[currentModuleIndex].lessons.length - 1;
            }
            
            loadLesson();
        }

        // Event listeners
        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
            mainContent.classList.toggle('sidebar-collapsed');
            sidebarToggle.classList.toggle('sidebar-open');
        });

        regexInput.addEventListener('input', validateRegex);

        regexInput.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                showHint();
            } else if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                nextLesson();
            }
        });

        prevBtn.addEventListener('click', previousLesson);
        nextBtn.addEventListener('click', nextLesson);
        hintBtn.addEventListener('click', showHint);
        solutionBtn.addEventListener('click', showSolution);
        continueBtn.addEventListener('click', () => {
            hideSuccess();
            nextLesson();
        });

        // Load saved progress
        const saved = localStorage.getItem('completedLessons');
        if (saved) {
            completedLessons = new Set(JSON.parse(saved));
        }

        // Initialize
        buildCourseIndex();
        loadLesson();
    </script>
</body>
</html>